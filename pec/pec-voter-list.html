<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEC Voter Filtering Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <style>
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <header>
        <h1>PEC Voter Filtering Tool  <span id="version">v0.62</span></h1>
    </header>
    <main>
        <section>
            <label>
                <input type="checkbox" id="hideSensitiveInfo" checked>
                Hide sensitive information
            </label>
        </section>
        <section>
            <div style="margin-top: 10px">
                <button id="generateTestData">Generate Test Data</button> or <input type="file" id="csvFileInput" accept=".csv">
            </div>
            <!-- <div style="margin-top: 10px;">
                <input type="number" id="numRowsInput" placeholder="Number of rows" style="width: 150px; margin-right: 10px;">
                <button id="generateTestData">Generate Test Data</button>
            </div> -->
        </section>
        <section>
            <div style="margin-top: 10px">
                <button id="downloadFilteredCsv">Download PEC Voter List</button>
            </div>
        </section>
        <section>
            <h3>PEC Voter List</h3>
            <table id="pecVoterListTable" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section>
            <h3>Duplicates (Age 19 and Above)</h3>
            <table id="dataPreview" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section>
            <h3>Age Below 19 or Age Unknown</h3>
            <table id="dataPreviewBelow19" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <!-- <section id="debugLogs">
            <h3>Debug Logs</h3>
        </section> -->
    </main>
    <footer>
        <p>&copy; 2025 PEC Voter List. All rights reserved.</p>
    </footer>

    <script>
        const csvFileInput = document.getElementById('csvFileInput');
        const generateTestDataButton = document.getElementById('generateTestData');
        const downloadFilteredCsv = document.getElementById('downloadFilteredCsv');
        const dataPreview = document.getElementById('dataPreview');

        let filteredData = [];

        // Function to update the state of the "Download PEC Voter List" button
        function updateDownloadButtonState() {
            if (filteredData.length > 0) {
                downloadFilteredCsv.disabled = false; // Enable the button if there is data
            } else {
                downloadFilteredCsv.disabled = true; // Disable the button if there is no data
            }
        }

        // Initialize the button state on page load
        updateDownloadButtonState();

        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                logMessage(`File selected: ${file.name}`); // Display file name on the page
                const reader = new FileReader();
                reader.onload = (e) => {
                    const csvData = e.target.result;
                    parseAndFilterData(csvData); // Use the shared parsing logic
                    updateDownloadButtonState(); // Update the button state after parsing
                };
                reader.readAsText(file);
            } else {
                logMessage("No file selected.");
                filteredData = []; // Clear the filtered data
                updateDownloadButtonState(); // Update the button state
            }
        });

        // Event listener for the Generate Test Data button
        generateTestDataButton.addEventListener('click', () => {
            // const numRowsInput = document.getElementById('numRowsInput');
            // const numRows = parseInt(numRowsInput.value, 10) || 200; // Default to 200 if input is empty or invalid
            //generateTestData(numRows);
            generateTestData(200); // Generate 200 rows of test data
            updateDownloadButtonState(); // Update the button state after generating test data
        });

        // Placeholder function for generating test data
        function generateTestData(numRows) {
            logMessage(`Generating ${numRows} rows of test data...`);

            // Header row
            const header = [
                "Family Name", "Address 1", "Address 2", "City, Province", "Postal", "Phone 1", "Phone 2", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env."
            ];

            // Pool of random names to introduce duplicates
            const namePool = [
                "John Doe", "Jane Smith", "Alice Johnson", "Bob Brown", "Charlie Davis",
                "Emily Wilson", "Michael Miller", "Sarah Taylor", "David Anderson", "Laura Thomas"
            ];

            // Pool of predefined birth dates to increase the chance of duplicates
            const birthDatePool = [
                "1980-01-01", "1990-05-15", "2000-10-20", "2010-03-25", "1975-07-30"
            ];

            // Helper function to calculate age from birth date
            function calculateAge(birthDate) {
                if (!birthDate) return ""; // Return empty if birth date is missing
                const today = new Date();
                const birth = new Date(birthDate);
                let age = today.getFullYear() - birth.getFullYear();
                const monthDiff = today.getMonth() - birth.getMonth();
                const dayDiff = today.getDate() - birth.getDate();
                if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
                    age--; // Adjust age if the birth date hasn't occurred yet this year
                }
                return age;
            }

            // Helper function to generate random phone numbers
            function generatePhoneNumbers() {
                const phoneCount = Math.floor(Math.random() * 3) + 1; // 1 to 3 phone numbers
                const phones = [];
                for (let i = 0; i < phoneCount; i++) {
                    phones.push(`(C) 555-${Math.floor(1000 + Math.random() * 9000)}`);
                }
                return phones.join(", "); // Combine phone numbers into a comma-separated string
            }

            // Helper function to generate a random Canadian postal code
            function generatePostalCode() {
                const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                const digits = "0123456789";
                return (
                    letters[Math.floor(Math.random() * letters.length)] +
                    digits[Math.floor(Math.random() * digits.length)] +
                    letters[Math.floor(Math.random() * letters.length)] +
                    " " +
                    digits[Math.floor(Math.random() * digits.length)] +
                    letters[Math.floor(Math.random() * letters.length)] +
                    digits[Math.floor(Math.random() * digits.length)]
                );
            }

            // Generate random data rows
            const dataRows = [];
            for (let i = 0; i < numRows; i++) {
                const familyName = `Family ${i + 1}`;
                const address1 = `${Math.floor(Math.random() * 10000)} Random Street`;
                const address2 = Math.random() > 0.5 ? "Apt " + Math.floor(Math.random() * 100) : "";
                const cityProvince = `City ${i % 50}, Province ${String.fromCharCode(65 + (i % 26))}`;
                const postal = generatePostalCode(); // Generate a valid Canadian postal code
                const phone1 = Math.random() > 0.5 ? `(H) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                const phone2 = Math.random() > 0.5 ? `(C) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                const env = `${Math.floor(Math.random() * 20)} Years`;

                // Generate personal records (0 to many)
                const numMembers = Math.floor(Math.random() * 5); // 0 to 4 members
                const personalRecords = [];
                for (let j = 0; j < numMembers; j++) {
                    const contactType = ["Primary", "Secondary", "Other"][Math.floor(Math.random() * 3)];
                    
                    // Randomly select a name from the pool, with a chance of reusing a name
                    const name = Math.random() > 0.7 
                        ? namePool[Math.floor(Math.random() * namePool.length)] // Reuse a name from the pool
                        : `Member ${j + 1} of Family ${i + 1}`; // Generate a unique name
                    
                    // Randomly select a birth date from the predefined pool
                    const birthDate = Math.random() > 0.2 // 20% chance of being empty
                        ? birthDatePool[Math.floor(Math.random() * birthDatePool.length)]
                        : "";

                    // Calculate age from birth date
                    const age = calculateAge(birthDate);
                    
                    const religion = ["Roman Catholic", "Protestant", "None", "Other"][Math.floor(Math.random() * 4)];
                    const phones = generatePhoneNumbers(); // Generate multiple phone numbers
                    const memberEnv = `${Math.floor(Math.random() * 10)} Years`;

                    personalRecords.push(contactType, name, birthDate, age, religion, phones, memberEnv);
                }

                // Fill remaining personal record columns with empty values
                while (personalRecords.length < 63) {
                    personalRecords.push("");
                }

                // Combine family-level data and personal records
                const row = [
                    familyName, address1, address2, cityProvince, postal, phone1, phone2, env,
                    ...personalRecords
                ];
                dataRows.push(row);
            }

            // Combine header and data rows
            const testData = [header, ...dataRows];

            // Convert test data to CSV format
            const csvData = Papa.unparse(testData);

            // Log the raw test data in CSV format
            logMessage(`Raw Test Data (CSV):\n${csvData}`);

            // Use the shared parsing logic
            parseAndFilterData(csvData);
        }

        // Function to display debugging messages on the page
        function logMessage(message) {
            // const logSection = document.getElementById('debugLogs');
            // const logMessage = document.createElement('p');
            // logMessage.textContent = message;
            // logSection.appendChild(logMessage);
        }

        function displayData(data, tableId) {
            const table = document.getElementById(tableId);
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');

            // Clear existing table content
            thead.innerHTML = '';
            tbody.innerHTML = '';

            // Display the total number of rows above the table
            const rowCountId = `${tableId}-rowCount`;
            let rowCountElement = document.getElementById(rowCountId);
            if (!rowCountElement) {
                rowCountElement = document.createElement('p');
                rowCountElement.id = rowCountId;
                table.parentElement.insertBefore(rowCountElement, table);
            }
            rowCountElement.textContent = `Total Rows: ${data.length}`;

            // Check if sensitive information should be hidden
            const hideSensitiveInfo = document.getElementById('hideSensitiveInfo').checked;
            const sensitiveColumns = ["Address 1", "Address 2", "City, Province", "Postal", "Age", "Family Name"];

            if (data.length > 0) {
                // Create table headers
                const headers = Object.keys(data[0]).filter(header => {
                    return !(hideSensitiveInfo && sensitiveColumns.includes(header));
                });
                const headerRow = document.createElement('tr');
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                // Create table rows
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    headers.forEach(header => {
                        const td = document.createElement('td');
                        if (hideSensitiveInfo && header === "Birth Date") {
                            // Extract only the day from the Birth Date
                            const birthDate = row[header];
                            if (birthDate) {
                                const day = new Date(birthDate).getUTCDate(); // Extract the day
                                td.textContent = day ? `${day}` : ""; // Display "Day X" or empty
                            } else {
                                td.textContent = ""; // Empty if no Birth Date
                            }
                        } else if (hideSensitiveInfo && header === "Phones") {
                            // Keep only the last four digits of each phone number
                            const phones = row[header];
                            if (phones) {
                                const maskedPhones = phones
                                    .split(", ") // Split the phone numbers into an array
                                    .map(phone => phone.slice(-4)) // Extract the last four digits
                                    .join(", "); // Join them back into a comma-separated string
                                td.textContent = maskedPhones;
                            } else {
                                td.textContent = ""; // Empty if no phone numbers
                            }
                        } else {
                            td.textContent = row[header];
                        }
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
            } else {
                const noDataRow = document.createElement('tr');
                const noDataCell = document.createElement('td');
                noDataCell.textContent = 'No data available';
                noDataCell.colSpan = Object.keys(data[0] || {}).length;
                noDataRow.appendChild(noDataCell);
                tbody.appendChild(noDataRow);
            }
        }

        downloadFilteredCsv.addEventListener('click', () => {
            if (filteredData.length > 0) {
                const csvContent = Papa.unparse(filteredData);
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'filtered_data.csv');
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert('No filtered data available to download.');
            }
        });

        function parseAndFilterData(csvData) {
            Papa.parse(csvData, {
                skipEmptyLines: true,
                complete: (results) => {
                    const rawData = results.data;

                    // Extract the header row as an array
                    const header = rawData[0]; // First row is the header
                    logMessage(`Header: ${JSON.stringify(header)}`);

                    // Extract the data rows
                    const dataRows = rawData.slice(1);
                    logMessage(`Number of data rows: ${dataRows.length}`);

                    // Define the desired column order
                    const desiredColumns = [
                        "Name", "Birth Date", "Age", "Phones", "Address 1", "Address 2",
                        "City, Province", "Postal", "Family Name", "Duplicate"
                    ];

                    // Process each data row
                    const allData = dataRows.flatMap(row => {
                        const familyData = {};
                        const members = [];

                        // Extract family-level data (before the first "Contact Type")
                        for (let i = 0; i < header.length; i++) {
                            if (header[i] === "Contact Type") break;
                            familyData[header[i]] = row[i];
                        }

                        // Extract personal records for each family member
                        let groupStartIndex = header.indexOf("Contact Type");
                        while (groupStartIndex !== -1 && groupStartIndex < header.length) {
                            const contactType = row[groupStartIndex];
                            const name = row[groupStartIndex + 1];
                            const birthDate = row[groupStartIndex + 2];
                            const age = row[groupStartIndex + 3];
                            const phones = row[groupStartIndex + 5];
                            const postal = familyData["Postal"];

                            if (name) { // Only include members with a name
                                // Combine phones with family-level phone numbers
                                const allPhones = [
                                    phones,
                                    familyData["Phone 1"],
                                    familyData["Phone 2"]
                                ]
                                    .filter(phone => phone) // Remove empty values
                                    .filter((phone, index, self) => self.indexOf(phone) === index) // Remove duplicates
                                    .join(", "); // Combine into a single string

                                members.push({
                                    Name: name,
                                    "Birth Date": birthDate,
                                    Age: age,
                                    Phones: allPhones, // Combined phone numbers
                                    "Address 1": familyData["Address 1"],
                                    "Address 2": familyData["Address 2"],
                                    "City, Province": familyData["City, Province"],
                                    Postal: postal,
                                    "Family Name": familyData["Family Name"],
                                    Duplicate: "" // Initialize Duplicate column
                                });
                            }

                            // Move to the next group of repeating columns
                            groupStartIndex = header.indexOf("Contact Type", groupStartIndex + 7);
                        }

                        return members;
                    });

                    // Separate data into three groups
                    const pecVoterList = [];
                    const ageAbove19 = [];
                    const ageBelow19 = [];

                    const seenNames = new Set();

                    allData.forEach(row => {
                        const age = parseInt(row.Age, 10);
                        if (isNaN(age) || age < 19) {
                            ageBelow19.push(row); // Add to Age Below 19 table
                        } else {
                            if (!seenNames.has(row.Name)) {
                                pecVoterList.push(row); // Add first occurrence to PEC Voter List
                                seenNames.add(row.Name);
                            } else {
                                ageAbove19.push(row); // Add remaining duplicates to Age 19 and Above table
                            }
                        }
                    });

                    // Combine all rows into a single array for global duplicate counting
                    const combinedData = [...pecVoterList, ...ageAbove19, ...ageBelow19];

                    // Count duplicates for each Name/Age pair globally
                    const countDuplicates = (data) => {
                        const counts = {};
                        data.forEach(row => {
                            const key = `${row.Name}-${row.Age}`;
                            counts[key] = (counts[key] || 0) + 1;
                        });
                        return counts;
                    };

                    const globalCounts = countDuplicates(combinedData);

                    // Update the Duplicate column with the global count of duplicates
                    const updateDuplicateColumn = (data, counts) => {
                        return data.map(row => {
                            const key = `${row.Name}-${row.Age}`;
                            row.Duplicate = counts[key] > 1 ? counts[key] : ""; // Add count if duplicates exist
                            return row;
                        });
                    };

                    const filteredDataBelow19 = updateDuplicateColumn(ageBelow19, globalCounts);
                    const filteredDataAbove19 = updateDuplicateColumn(ageAbove19, globalCounts);
                    const pecVoterListData = updateDuplicateColumn(pecVoterList, globalCounts);

                    // Sort data by Name (A to Z) and then by Age (oldest to youngest)
                    const sortData = (data) => {
                        return data.sort((a, b) => {
                            const nameA = a.Name.toLowerCase();
                            const nameB = b.Name.toLowerCase();

                            // Primary sort: Name
                            if (nameA < nameB) return -1;
                            if (nameA > nameB) return 1;

                            // Secondary sort: Age (oldest to youngest)
                            const ageA = parseInt(a.Age, 10) || 0;
                            const ageB = parseInt(b.Age, 10) || 0;
                            return ageB - ageA;
                        });
                    };

                    const sortedDataBelow19 = sortData(filteredDataBelow19);
                    const sortedDataAbove19 = sortData(filteredDataAbove19);
                    const sortedPecVoterList = sortData(pecVoterListData);

                    // Reorder columns based on the desired order
                    const reorderColumns = (data) => {
                        return data.map(row => {
                            const reorderedRow = {};
                            desiredColumns.forEach(column => {
                                reorderedRow[column] = row[column] || ""; // Include only desired columns
                            });
                            return reorderedRow;
                        });
                    };

                    const finalDataBelow19 = reorderColumns(sortedDataBelow19);
                    const finalDataAbove19 = reorderColumns(sortedDataAbove19);
                    const finalPecVoterList = reorderColumns(sortedPecVoterList);

                    // Use the filterDataObject function to filter the PEC Voter List
                    filteredData = filterDataObject(finalPecVoterList);

                    // Display the data in the respective tables
                    displayData(finalDataBelow19, "dataPreviewBelow19");
                    displayData(finalDataAbove19, "dataPreview");
                    displayData(finalPecVoterList, "pecVoterListTable");
                },
                error: (error) => {
                    logMessage(`Error parsing CSV: ${error.message}`);
                }
            });
        }

        function filterDataObject(data) {
            const filterData = [];

            // Check if sensitive information should be hidden
            const hideSensitiveInfo = document.getElementById('hideSensitiveInfo').checked;
            const sensitiveColumns = ["Address 1", "Address 2", "City, Province", "Postal", "Age", "Family Name"];

            if (data.length > 0) {
                // Filter headers based on sensitive information
                const headers = Object.keys(data[0]).filter(header => {
                    return !(hideSensitiveInfo && sensitiveColumns.includes(header));
                });

                // Process each row
                data.forEach(row => {
                    const filteredRow = {};
                    headers.forEach(header => {
                        if (hideSensitiveInfo && header === "Birth Date") {
                            // Extract only the day from the Birth Date
                            const birthDate = row[header];
                            if (birthDate) {
                                const day = new Date(birthDate).getUTCDate(); // Extract the day in UTC
                                filteredRow[header] = day ? `${day}` : ""; // Store "Day X" or empty
                            } else {
                                filteredRow[header] = ""; // Empty if no Birth Date
                            }
                        } else if (hideSensitiveInfo && header === "Phones") {
                            // Keep only the last four digits of each phone number
                            const phones = row[header];
                            if (phones) {
                                const maskedPhones = phones
                                    .split(", ") // Split the phone numbers into an array
                                    .map(phone => phone.slice(-4)) // Extract the last four digits
                                    .join(", "); // Join them back into a comma-separated string
                                filteredRow[header] = maskedPhones;
                            } else {
                                filteredRow[header] = ""; // Empty if no phone numbers
                            }
                        } else {
                            filteredRow[header] = row[header]; // Store the original value
                        }
                    });
                    filterData.push(filteredRow);
                });
            }

            return filterData;
        }
    </script>
</body>
</html>