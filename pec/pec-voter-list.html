<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEC Voter Filtering Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <header>
        <h1>PEC Voter List  <span id="version">v0.26</span></h1>
    </header>
    <main>
        <section>
            <h2>Upload and Filter CSV</h2>
            <input type="file" id="csvFileInput" accept=".csv">
            <div style="margin-top: 10px;">
                <input type="number" id="numRowsInput" placeholder="Number of rows" style="width: 150px; margin-right: 10px;">
                <button id="generateTestData">Generate Test Data</button>
            </div>
            <button id="downloadFilteredCsv">Download Filtered CSV</button>
        </section>
        <section>
            <h3>Filtered Data Preview (Age 19 and Above)</h3>
            <table id="dataPreview" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section>
            <h3>Filtered Data Preview (Age Below 19)</h3>
            <table id="dataPreviewBelow19" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section id="debugLogs">
            <h3>Debug Logs</h3>
        </section>
    </main>
    <footer>
        <p>&copy; 2025 PEC Voter List. All rights reserved.</p>
    </footer>

    <script>
        const csvFileInput = document.getElementById('csvFileInput');
        const generateTestDataButton = document.getElementById('generateTestData');
        const downloadFilteredCsv = document.getElementById('downloadFilteredCsv');
        const dataPreview = document.getElementById('dataPreview');

        let filteredData = [];

        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                logMessage(`File selected: ${file.name}`); // Display file name on the page
                const reader = new FileReader();
                reader.onload = (e) => {
                    const csvData = e.target.result;
                    parseAndFilterData(csvData); // Use the shared parsing logic
                };
                reader.readAsText(file);
            } else {
                logMessage("No file selected.");
            }
        });

        // Event listener for the Generate Test Data button
        generateTestDataButton.addEventListener('click', () => {
            const numRowsInput = document.getElementById('numRowsInput');
            const numRows = parseInt(numRowsInput.value, 10) || 200; // Default to 200 if input is empty or invalid
            generateTestData(numRows);
        });

        // Placeholder function for generating test data
        function generateTestData(numRows) {
            logMessage(`Generating ${numRows} rows of test data...`);

            // Header row
            const header = [
                "Family Name", "Address 1", "Address 2", "City, Province", "Postal", "Phone 1", "Phone 2", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env."
            ];

            // Pool of random names to introduce duplicates
            const namePool = [
                "John Doe", "Jane Smith", "Alice Johnson", "Bob Brown", "Charlie Davis",
                "Emily Wilson", "Michael Miller", "Sarah Taylor", "David Anderson", "Laura Thomas"
            ];

            // Helper function to calculate age from birth date
            function calculateAge(birthDate) {
                if (!birthDate) return ""; // Return empty if birth date is missing
                const today = new Date();
                const birth = new Date(birthDate);
                let age = today.getFullYear() - birth.getFullYear();
                const monthDiff = today.getMonth() - birth.getMonth();
                const dayDiff = today.getDate() - birth.getDate();
                if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
                    age--; // Adjust age if the birth date hasn't occurred yet this year
                }
                return age;
            }

            // Generate random data rows
            const dataRows = [];
            for (let i = 0; i < numRows; i++) {
                const familyName = `Family ${i + 1}`;
                const address1 = `${Math.floor(Math.random() * 10000)} Random Street`;
                const address2 = Math.random() > 0.5 ? "Apt " + Math.floor(Math.random() * 100) : "";
                const cityProvince = `City ${i % 50}, Province ${String.fromCharCode(65 + (i % 26))}`;
                const postal = `P${Math.floor(Math.random() * 10)}C ${Math.floor(Math.random() * 10)}${Math.floor(Math.random() * 10)}`;
                const phone1 = Math.random() > 0.5 ? `(H) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                const phone2 = Math.random() > 0.5 ? `(C) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                const env = `${Math.floor(Math.random() * 20)} Years`;

                // Generate personal records (0 to many)
                const numMembers = Math.floor(Math.random() * 5); // 0 to 4 members
                const personalRecords = [];
                for (let j = 0; j < numMembers; j++) {
                    const contactType = ["Primary", "Secondary", "Other"][Math.floor(Math.random() * 3)];
                    
                    // Randomly select a name from the pool, with a chance of reusing a name
                    const name = Math.random() > 0.7 
                        ? namePool[Math.floor(Math.random() * namePool.length)] // Reuse a name from the pool
                        : `Member ${j + 1} of Family ${i + 1}`; // Generate a unique name
                    
                    // Randomly set Birth Date to empty
                    const birthDate = Math.random() > 0.5 // 50% chance of being empty
                        ? `${1970 + Math.floor(Math.random() * 50)}-${String(Math.floor(1 + Math.random() * 12)).padStart(2, "0")}-${String(Math.floor(1 + Math.random() * 28)).padStart(2, "0")}`
                        : "";

                    // Calculate age from birth date
                    const age = calculateAge(birthDate);
                    
                    const religion = ["Roman Catholic", "Protestant", "None", "Other"][Math.floor(Math.random() * 4)];
                    const phones = Math.random() > 0.5 ? `(C) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                    const memberEnv = `${Math.floor(Math.random() * 10)} Years`;

                    personalRecords.push(contactType, name, birthDate, age, religion, phones, memberEnv);
                }

                // Fill remaining personal record columns with empty values
                while (personalRecords.length < 63) {
                    personalRecords.push("");
                }

                // Combine family-level data and personal records
                const row = [
                    familyName, address1, address2, cityProvince, postal, phone1, phone2, env,
                    ...personalRecords
                ];
                dataRows.push(row);
            }

            // Combine header and data rows
            const testData = [header, ...dataRows];

            // Convert test data to CSV format
            const csvData = Papa.unparse(testData);

            // Log the raw test data in CSV format
            logMessage(`Raw Test Data (CSV):\n${csvData}`);

            // Use the shared parsing logic
            parseAndFilterData(csvData);
        }

        // Function to display debugging messages on the page
        function logMessage(message) {
            const logSection = document.getElementById('debugLogs');
            const logMessage = document.createElement('p');
            logMessage.textContent = message;
            logSection.appendChild(logMessage);
        }

        function displayData(data) {
            const thead = dataPreview.querySelector('thead');
            const tbody = dataPreview.querySelector('tbody');
            const theadBelow19 = document.getElementById('dataPreviewBelow19').querySelector('thead');
            const tbodyBelow19 = document.getElementById('dataPreviewBelow19').querySelector('tbody');

            // Clear existing table content
            thead.innerHTML = '';
            tbody.innerHTML = '';
            theadBelow19.innerHTML = '';
            tbodyBelow19.innerHTML = '';

            // Clear existing row count messages
            const rowCountAbove19 = document.getElementById('rowCountAbove19');
            const rowCountBelow19 = document.getElementById('rowCountBelow19');
            if (rowCountAbove19) rowCountAbove19.remove();
            if (rowCountBelow19) rowCountBelow19.remove();

            if (data.length > 0) {
                // Split data into two groups: Age 19 and above, and Age below 19
                const dataAbove19 = data.filter(row => parseInt(row.Age, 10) >= 19);
                const dataBelow19 = data.filter(row => parseInt(row.Age, 10) < 19);

                // Display row count for Age 19 and above
                const above19Count = document.createElement('p');
                above19Count.id = 'rowCountAbove19';
                above19Count.textContent = `Number of rows: ${dataAbove19.length}`;
                dataPreview.parentElement.insertBefore(above19Count, dataPreview);

                // Display data for Age 19 and above
                if (dataAbove19.length > 0) {
                    const headers = Object.keys(dataAbove19[0]);
                    const headerRow = document.createElement('tr');
                    headers.forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    dataAbove19.forEach(row => {
                        const tr = document.createElement('tr');
                        headers.forEach(header => {
                            const td = document.createElement('td');
                            td.textContent = row[header];
                            tr.appendChild(td);
                        });
                        tbody.appendChild(tr);
                    });
                }

                // Display row count for Age below 19
                const below19Count = document.createElement('p');
                below19Count.id = 'rowCountBelow19';
                below19Count.textContent = `Number of rows: ${dataBelow19.length}`;
                document.getElementById('dataPreviewBelow19').parentElement.insertBefore(below19Count, document.getElementById('dataPreviewBelow19'));

                // Display data for Age below 19
                if (dataBelow19.length > 0) {
                    const headers = Object.keys(dataBelow19[0]);
                    const headerRow = document.createElement('tr');
                    headers.forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow.appendChild(th);
                    });
                    theadBelow19.appendChild(headerRow);

                    dataBelow19.forEach(row => {
                        const tr = document.createElement('tr');
                        headers.forEach(header => {
                            const td = document.createElement('td');
                            td.textContent = row[header];
                            tr.appendChild(td);
                        });
                        tbodyBelow19.appendChild(tr);
                    });
                }
            } else {
                console.warn("No data to display."); // Debugging: Log if no data is available
                alert("No data to display.");
            }
        }

        downloadFilteredCsv.addEventListener('click', () => {
            if (filteredData.length > 0) {
                const csvContent = Papa.unparse(filteredData);
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'filtered_data.csv');
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert('No filtered data available to download.');
            }
        });

        function parseAndFilterData(csvData) {
            Papa.parse(csvData, {
                skipEmptyLines: true,
                complete: (results) => {
                    const rawData = results.data;

                    // Extract the header row as an array
                    const header = rawData[0]; // First row is the header
                    logMessage(`Header: ${JSON.stringify(header)}`);

                    // Extract the data rows
                    const dataRows = rawData.slice(1);
                    logMessage(`Number of data rows: ${dataRows.length}`);

                    // Define the desired column order
                    const desiredColumns = [
                        "Name", "Birth Date", "Age", "Phones", "Phone 1", "Phone 2",
                        "Address 1", "Address 2", "City, Province", "Postal", "Family Name", "Duplicate"
                    ];

                    // Process each data row
                    filteredData = dataRows.flatMap(row => {
                        const familyData = {};
                        const members = [];

                        // Extract family-level data (before the first "Contact Type")
                        for (let i = 0; i < header.length; i++) {
                            if (header[i] === "Contact Type") break;
                            familyData[header[i]] = row[i];
                        }

                        // Extract personal records for each family member
                        let groupStartIndex = header.indexOf("Contact Type");
                        while (groupStartIndex !== -1 && groupStartIndex < header.length) {
                            const contactType = row[groupStartIndex];
                            const name = row[groupStartIndex + 1];
                            const birthDate = row[groupStartIndex + 2];
                            const age = row[groupStartIndex + 3];
                            const religion = row[groupStartIndex + 4];
                            const phones = row[groupStartIndex + 5];
                            const memberEnv = row[groupStartIndex + 6];

                            if (name) { // Only include members with a name
                                members.push({
                                    Name: name,
                                    "Birth Date": birthDate,
                                    Age: age,
                                    Phones: phones,
                                    "Phone 1": familyData["Phone 1"],
                                    "Phone 2": familyData["Phone 2"],
                                    "Address 1": familyData["Address 1"],
                                    "Address 2": familyData["Address 2"],
                                    "City, Province": familyData["City, Province"],
                                    Postal: familyData["Postal"],
                                    "Family Name": familyData["Family Name"],
                                    Duplicate: "" // Initialize Duplicate column
                                });
                            }

                            // Move to the next group of repeating columns
                            groupStartIndex = header.indexOf("Contact Type", groupStartIndex + 7);
                        }

                        return members;
                    });

                    // Reorder columns based on the desired order
                    filteredData = filteredData.map(row => {
                        const reorderedRow = {};
                        desiredColumns.forEach(column => {
                            reorderedRow[column] = row[column] || ""; // Include only desired columns
                        });
                        return reorderedRow;
                    });

                    // Identify duplicates in the Name column
                    const nameCounts = {};
                    filteredData.forEach(row => {
                        const name = row.Name;
                        if (name) {
                            nameCounts[name] = (nameCounts[name] || 0) + 1;
                        }
                    });

                    // Mark duplicates in the Duplicate column
                    filteredData.forEach(row => {
                        if (nameCounts[row.Name] > 1) {
                            row.Duplicate = "x";
                        }
                    });

                    // Sort the filtered data by the Name column (primary) and Age column (secondary)
                    filteredData.sort((a, b) => {
                        const nameA = a.Name.toLowerCase();
                        const nameB = b.Name.toLowerCase();

                        // Primary sort: Name
                        if (nameA < nameB) return -1;
                        if (nameA > nameB) return 1;

                        // Secondary sort: Age (numerical comparison)
                        const ageA = parseInt(a.Age, 10) || 0; // Default to 0 if Age is missing or invalid
                        const ageB = parseInt(b.Age, 10) || 0;
                        return ageA - ageB;
                    });

                    logMessage(`Filtered Data (Sorted by Name and Marked Duplicates): ${JSON.stringify(filteredData)}`);
                    displayData(filteredData);
                },
                error: (error) => {
                    logMessage(`Error parsing CSV: ${error.message}`);
                }
            });
        }
    </script>
</body>
</html>