<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEC Voter Filtering Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <header>
        <h1>PEC Voter List  <span id="version">v0.37</span></h1>
    </header>
    <main>
        <section>
            <h2>Upload and Filter CSV</h2>
            <input type="file" id="csvFileInput" accept=".csv">
            <div style="margin-top: 10px;">
                <input type="number" id="numRowsInput" placeholder="Number of rows" style="width: 150px; margin-right: 10px;">
                <button id="generateTestData">Generate Test Data</button>
            </div>
            <button id="downloadFilteredCsv">Download Filtered CSV</button>
        </section>
        <section>
            <h3>PEC Voter List</h3>
            <table id="pecVoterListTable" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section>
            <h3>Filtered Data Preview (Age 19 and Above)</h3>
            <table id="dataPreview" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section>
            <h3>Filtered Data Preview (Age Below 19)</h3>
            <table id="dataPreviewBelow19" border="1">
                <thead></thead>
                <tbody></tbody>
            </table>
        </section>
        <section id="debugLogs">
            <h3>Debug Logs</h3>
        </section>
    </main>
    <footer>
        <p>&copy; 2025 PEC Voter List. All rights reserved.</p>
    </footer>

    <script>
        const csvFileInput = document.getElementById('csvFileInput');
        const generateTestDataButton = document.getElementById('generateTestData');
        const downloadFilteredCsv = document.getElementById('downloadFilteredCsv');
        const dataPreview = document.getElementById('dataPreview');

        let filteredData = [];

        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                logMessage(`File selected: ${file.name}`); // Display file name on the page
                const reader = new FileReader();
                reader.onload = (e) => {
                    const csvData = e.target.result;
                    parseAndFilterData(csvData); // Use the shared parsing logic
                };
                reader.readAsText(file);
            } else {
                logMessage("No file selected.");
            }
        });

        // Event listener for the Generate Test Data button
        generateTestDataButton.addEventListener('click', () => {
            const numRowsInput = document.getElementById('numRowsInput');
            const numRows = parseInt(numRowsInput.value, 10) || 200; // Default to 200 if input is empty or invalid
            generateTestData(numRows);
        });

        // Placeholder function for generating test data
        function generateTestData(numRows) {
            logMessage(`Generating ${numRows} rows of test data...`);

            // Header row
            const header = [
                "Family Name", "Address 1", "Address 2", "City, Province", "Postal", "Phone 1", "Phone 2", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env.",
                "Contact Type", "Name", "Birth Date", "Age", "Religion", "Phones", "Env."
            ];

            // Pool of random names to introduce duplicates
            const namePool = [
                "John Doe", "Jane Smith", "Alice Johnson", "Bob Brown", "Charlie Davis",
                "Emily Wilson", "Michael Miller", "Sarah Taylor", "David Anderson", "Laura Thomas"
            ];

            // Pool of predefined birth dates to increase the chance of duplicates
            const birthDatePool = [
                "1980-01-01", "1990-05-15", "2000-10-20", "2010-03-25", "1975-07-30"
            ];

            // Helper function to calculate age from birth date
            function calculateAge(birthDate) {
                if (!birthDate) return ""; // Return empty if birth date is missing
                const today = new Date();
                const birth = new Date(birthDate);
                let age = today.getFullYear() - birth.getFullYear();
                const monthDiff = today.getMonth() - birth.getMonth();
                const dayDiff = today.getDate() - birth.getDate();
                if (monthDiff < 0 || (monthDiff === 0 && dayDiff < 0)) {
                    age--; // Adjust age if the birth date hasn't occurred yet this year
                }
                return age;
            }

            // Generate random data rows
            const dataRows = [];
            for (let i = 0; i < numRows; i++) {
                const familyName = `Family ${i + 1}`;
                const address1 = `${Math.floor(Math.random() * 10000)} Random Street`;
                const address2 = Math.random() > 0.5 ? "Apt " + Math.floor(Math.random() * 100) : "";
                const cityProvince = `City ${i % 50}, Province ${String.fromCharCode(65 + (i % 26))}`;
                const postal = `P${Math.floor(Math.random() * 10)}C ${Math.floor(Math.random() * 10)}${Math.floor(Math.random() * 10)}`;
                const phone1 = Math.random() > 0.5 ? `(H) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                const phone2 = Math.random() > 0.5 ? `(C) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                const env = `${Math.floor(Math.random() * 20)} Years`;

                // Generate personal records (0 to many)
                const numMembers = Math.floor(Math.random() * 5); // 0 to 4 members
                const personalRecords = [];
                for (let j = 0; j < numMembers; j++) {
                    const contactType = ["Primary", "Secondary", "Other"][Math.floor(Math.random() * 3)];
                    
                    // Randomly select a name from the pool, with a chance of reusing a name
                    const name = Math.random() > 0.7 
                        ? namePool[Math.floor(Math.random() * namePool.length)] // Reuse a name from the pool
                        : `Member ${j + 1} of Family ${i + 1}`; // Generate a unique name
                    
                    // Randomly select a birth date from the predefined pool
                    const birthDate = Math.random() > 0.2 // 20% chance of being empty
                        ? birthDatePool[Math.floor(Math.random() * birthDatePool.length)]
                        : "";

                    // Calculate age from birth date
                    const age = calculateAge(birthDate);
                    
                    const religion = ["Roman Catholic", "Protestant", "None", "Other"][Math.floor(Math.random() * 4)];
                    const phones = Math.random() > 0.5 ? `(C) 555-${Math.floor(1000 + Math.random() * 9000)}` : "";
                    const memberEnv = `${Math.floor(Math.random() * 10)} Years`;

                    personalRecords.push(contactType, name, birthDate, age, religion, phones, memberEnv);
                }

                // Fill remaining personal record columns with empty values
                while (personalRecords.length < 63) {
                    personalRecords.push("");
                }

                // Combine family-level data and personal records
                const row = [
                    familyName, address1, address2, cityProvince, postal, phone1, phone2, env,
                    ...personalRecords
                ];
                dataRows.push(row);
            }

            // Combine header and data rows
            const testData = [header, ...dataRows];

            // Convert test data to CSV format
            const csvData = Papa.unparse(testData);

            // Log the raw test data in CSV format
            logMessage(`Raw Test Data (CSV):\n${csvData}`);

            // Use the shared parsing logic
            parseAndFilterData(csvData);
        }

        // Function to display debugging messages on the page
        function logMessage(message) {
            const logSection = document.getElementById('debugLogs');
            const logMessage = document.createElement('p');
            logMessage.textContent = message;
            logSection.appendChild(logMessage);
        }

        function displayData(data, tableId) {
            const table = document.getElementById(tableId);
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');

            // Clear existing table content
            thead.innerHTML = '';
            tbody.innerHTML = '';

            if (data.length > 0) {
                // Create table headers
                const headers = Object.keys(data[0]);
                const headerRow = document.createElement('tr');
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                // Create table rows
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    headers.forEach(header => {
                        const td = document.createElement('td');
                        td.textContent = row[header];
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
            } else {
                const noDataRow = document.createElement('tr');
                const noDataCell = document.createElement('td');
                noDataCell.textContent = 'No data available';
                noDataCell.colSpan = Object.keys(data[0] || {}).length;
                noDataRow.appendChild(noDataCell);
                tbody.appendChild(noDataRow);
            }
        }

        downloadFilteredCsv.addEventListener('click', () => {
            if (filteredData.length > 0) {
                const csvContent = Papa.unparse(filteredData);
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'filtered_data.csv');
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert('No filtered data available to download.');
            }
        });

        function parseAndFilterData(csvData) {
            Papa.parse(csvData, {
                skipEmptyLines: true,
                complete: (results) => {
                    const rawData = results.data;

                    // Extract the header row as an array
                    const header = rawData[0]; // First row is the header
                    logMessage(`Header: ${JSON.stringify(header)}`);

                    // Extract the data rows
                    const dataRows = rawData.slice(1);
                    logMessage(`Number of data rows: ${dataRows.length}`);

                    // Define the desired column order
                    const desiredColumns = [
                        "Name", "Birth Date", "Age", "Phones", "Address 1", "Address 2",
                        "City, Province", "Postal", "Family Name", "Duplicate", "No Members"
                    ];

                    // Process each data row
                    const allData = dataRows.flatMap(row => {
                        const familyData = {};
                        const members = [];

                        // Extract family-level data (before the first "Contact Type")
                        for (let i = 0; i < header.length; i++) {
                            if (header[i] === "Contact Type") break;
                            familyData[header[i]] = row[i];
                        }

                        // Extract personal records for each family member
                        let groupStartIndex = header.indexOf("Contact Type");
                        while (groupStartIndex !== -1 && groupStartIndex < header.length) {
                            const contactType = row[groupStartIndex];
                            const name = row[groupStartIndex + 1];
                            const birthDate = row[groupStartIndex + 2];
                            const age = row[groupStartIndex + 3];
                            const phones = row[groupStartIndex + 5];
                            const postal = familyData["Postal"];

                            if (name) { // Only include members with a name
                                members.push({
                                    Name: name,
                                    "Birth Date": birthDate,
                                    Age: age,
                                    Phones: phones,
                                    "Address 1": familyData["Address 1"],
                                    "Address 2": familyData["Address 2"],
                                    "City, Province": familyData["City, Province"],
                                    Postal: postal,
                                    "Family Name": familyData["Family Name"],
                                    Duplicate: "", // Initialize Duplicate column
                                    "No Members": "" // Initialize No Members column
                                });
                            }

                            // Move to the next group of repeating columns
                            groupStartIndex = header.indexOf("Contact Type", groupStartIndex + 7);
                        }

                        return members;
                    });

                    // Separate data into three groups
                    const pecVoterList = [];
                    const ageAbove19 = [];
                    const ageBelow19 = [];

                    const seenNames = new Set();

                    allData.forEach(row => {
                        const age = parseInt(row.Age, 10);
                        if (isNaN(age) || age < 19) {
                            ageBelow19.push(row); // Add to Age Below 19 table
                        } else {
                            if (!seenNames.has(row.Name)) {
                                pecVoterList.push(row); // Add first occurrence to PEC Voter List
                                seenNames.add(row.Name);
                            } else {
                                ageAbove19.push(row); // Add remaining duplicates to Age 19 and Above table
                            }
                        }
                    });

                    // Sort data by Name (A to Z) and then by Age (oldest to youngest)
                    const sortData = (data) => {
                        return data.sort((a, b) => {
                            const nameA = a.Name.toLowerCase();
                            const nameB = b.Name.toLowerCase();

                            // Primary sort: Name
                            if (nameA < nameB) return -1;
                            if (nameA > nameB) return 1;

                            // Secondary sort: Age (oldest to youngest)
                            const ageA = parseInt(a.Age, 10) || 0;
                            const ageB = parseInt(b.Age, 10) || 0;
                            return ageB - ageA;
                        });
                    };

                    const filteredDataBelow19 = sortData(ageBelow19);
                    const filteredDataAbove19 = sortData(ageAbove19);
                    const pecVoterListData = sortData(pecVoterList);

                    // Reorder columns based on the desired order
                    const reorderColumns = (data) => {
                        return data.map(row => {
                            const reorderedRow = {};
                            desiredColumns.forEach(column => {
                                reorderedRow[column] = row[column] || ""; // Include only desired columns
                            });
                            return reorderedRow;
                        });
                    };

                    const finalDataBelow19 = reorderColumns(filteredDataBelow19);
                    const finalDataAbove19 = reorderColumns(filteredDataAbove19);
                    const finalPecVoterList = reorderColumns(pecVoterListData);

                    // Display the data in the respective tables
                    displayData(finalDataBelow19, "dataPreviewBelow19");
                    displayData(finalDataAbove19, "dataPreview");
                    displayData(finalPecVoterList, "pecVoterListTable");
                },
                error: (error) => {
                    logMessage(`Error parsing CSV: ${error.message}`);
                }
            });
        }
    </script>
</body>
</html>